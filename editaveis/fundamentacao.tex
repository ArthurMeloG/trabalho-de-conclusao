\chapter[Fundamentação Teórica]{Fundamentação Teórica}
\label{cap:fundamentacao}
\addcontentsline{toc}{chapter}{Fundamentação Teórica}

\section{Considerações iniciais}

Neste capítulo, apresenta-se o referencial teórico deste trabalho. Serão apresentadas as tecnologias utilizadas no desenvolvimento do sistema, sua arquitetura, bem como algumas ferramentas empregadas pela equipe durante o processo de construção do sistema.

\section{Descentralização e Tecnologias Distribuídas}

\subsection{Redes \textit{peer-to-peer}}
As redes \textit{peer-to-peer}, ou \textit{P2P}, são uma série de computadores de uma rede interligados em uma cadeia descentralizada, onde cada um possui uma função equivalente, não havendo uma hierarquia entre eles, e portanto, sem a existência de um servidor central \cite{otton2007}.Essa é uma das características mais impactantes da descentralização: a ênfase na posse e controle dos dados e recursos pelos próprios usuários. Em um sistema verdadeiramente descentralizado, cada par (peer) tem um papel de participante igualitário. \cite{oram2002}

De acordo com Barcellos e Gaspary \cite{barcellos2006}, as razões pelas quais este modelo de computação é atrativo se resumem em 3:
\begin{itemize}
    \item Redes \textit{P2P} são escaláveis, ou seja, lidam eficientemente tanto com grupos pequenos quanto grupos grandes de participantes. 
    \item É possível depender mais do funcionamente dessas redes, já que não possuem um servidor central, e assim são mais resistentes a ataques ou censuras.
    \item Redes \textit{P2P} oferecem autonomia aos seus participantes, possibilitando que entrem em saiam da rede de acordo com sua vontade. 
\end{itemize}

\section{A tecnologia no suporte e complemento da educação}

Historicamente, o professor era a figura central das reuniões e salas de aulas, sendo este e os livros os possuidores de todo conteúdo, e por meio dos mesmos, o conhecimento era transimitido de forma unilateral. Este modelo tradicional predominou por muitos anos, caracterizando-se por aulas expositivas e memorização \cite{unicep2024}.

A digitalização surgiu como uma força disruptiva, mudando por completo o modelo tradicional de educação. Ferramentas digitais, plataformas online, e outros instrumentos passaram a ser participantes do processo de aprendizagem, facilitando o acesso ao conhecimento em uma larga escala. \cite{unicep2024}.

\section{tecnologias da aplicação}

\subsection{O \textit{InterPlanetary File System} (IPFS)}

Neste projeto, o foco é desenvolver uma plataforma descentralizada para cursos e materiais educativos utilizando o IPFS para garantir que os dados permaneçam sob o controle direto de seus criadores. A aplicação será responsável por gerenciar os dados dos usuários e no controle dos meios de pagamento através da rede \textit{Lightning Network} \cite{lightningnetwork} para os conteúdos privados criptografados. Tanto os materiais públicos quanto os privados serão persistidos na rede IPFS. Dessa forma, mesmo que eventualmente essa aplicação saia de circulação ou seja bloqueada, os dados permanecerão disponíveis globalmente ao público.

O IPFS é um protocolo distribuído para armazenamento e compartilhamento de dados, que organiza arquivos em uma estrutura baseada em conteúdo, tornando a web mais eficiente e resistente a falhas \cite{ipfs2025}. Com ele é possível persistir os dados da aplicação entre os nós da rede. Isso o torna público, de fato, e replicável por quaisquer usuários que quiserem. Diferente do HTTP, que carrega arquivos de um servidor, o IPFS utiliza um modelo de endereçamento de conteúdo, em que os dados não desacoplados de sua localização e tratados a partir da hash única gerada pelo conteúdo do mesmo.

Entre suas principais características, destacam-se:

\begin{itemize}
    \item \textbf{Identificadores de Conteúdo (CIDs - Content Identifiers)}: cada conteúdo ou arquivo é associado a um endereço único baseado em um hash criptográfico, garantindo sua integridade e imutabilidade.
    
    \item \textbf{Rede Peer-to-Peer (P2P)}: milhares de nós interconectados facilitam a localização e recuperação dos dados distribuídos na rede.
    
    \item \textbf{Armazenamento em Cache}: os dados são armazenados temporariamente na memória cache dos nós, otimizando a largura de banda e melhorando a eficiência na redistribuição de conteúdos.
\end{itemize}

\subsection{OrbitDB: Banco de Dados Distribuído}

O OrbitDB é um banco de dados \textit{serverless} e ponto a ponto (\textit{peer-to-peer}), distribuído. Construído para atuar em aplicações descentralizadas, ele utiliza o IPFS para o armazenamento e sincronia dos dados entre os diferentes nós. Ele será utilizado no projeto para realizar a comunicação e persistência dos dados com a rede IPFS.

Escrito em \textit{JavaScript}, o \textit{OrbitDB} o oferece uma integração perfeita com o NestJS, facilitando o desenvolvimento do Software e possibilitando escalabilidade e flexibilidade no acesso offline entre os nós da aplicação.

\subsubsection*{Pontos Fortes do OrbitDB:}
\begin{itemize}
    \item \textbf{Descentralização}: Dispensa a necessidade de servidores centralizados.
    \item \textbf{Alta disponibilidade}: Suporta replicação automática e sincronização entre nós.
    \item \textbf{Desempenho escalável}: Ideal para aplicações distribuídas que requerem persistência de dados em tempo real.
    \item \textbf{Fácil integração}: Compatível com tecnologias baseadas em JavaScript.
\end{itemize}

\subsection{NestJS}

NestJS é uma estrutura para construir aplicativos Node.js eficientes e escaláveis. Ele utiliza JavaScript progressivo, sendo construído com e oferecendo suporte total a TypeScript (mas ainda permitindo que os desenvolvedores codifiquem em JavaScript puro). Ele combina elementos de POO (Programação Orientada a Objetos), FP (Programação Funcional) e FRP (Programação Reativa Funcional) \cite{nestjs2025}.

\subsubsection*{Pontos Fortes do NestJS:}
\begin{itemize}
    \item \textbf{Modularidade}: Arquitetura que facilita a divisão da aplicação em módulos reutilizáveis.
    \item \textbf{Integração simples com bancos de dados}: Compatível com ORM populares, como TypeORM e Prisma.
    \item \textbf{Injeção de Dependência}: Simplifica o gerenciamento de dependências e aumenta a testabilidade.
    \item \textbf{Flexibilidade}: Suporta diversos paradigmas, como programação reativa e microsserviços.
\end{itemize}

\subsection{Next.js}

O \textbf{Next.js} é um framework \textit{React} para desenvolvimento de aplicações no lado do cliente. Ele oferece recursos como renderização no lado do servidor (\textit{Server-Side Rendering} - SSR) e geração de sites estáticos (\textit{Static Site Generation} - SSG), que permitem criar interfaces modernas com excelente desempenho.

\subsubsection*{Pontos Fortes do Next.js:}
\begin{itemize}
    \item \textbf{Renderização otimizada}: Suporte a SSR e SSG, melhorando o desempenho e SEO.
    \item \textbf{Rotas automáticas}: Simplifica a estrutura de navegação com rotas baseadas em arquivos.
    \item \textbf{Desenvolvimento eficiente}: Hot reloading e compilação automática durante o desenvolvimento.
    \item \textbf{API Routes}: Permite criar APIs no mesmo projeto do front-end.
    \item \textbf{Suporte ativo da comunidade}: Grande número de extensões e soluções prontas.
\end{itemize}

\subsection{PostgreSQL}

O \textbf{PostgreSQL} é um banco de dados relacional muito utilizado no desenvolvimento web. Conhecido por sua flexibilidade e robustez em diagramas relacionais. 

\subsubsection*{Pontos Fortes do PostgreSQL:}
\begin{itemize}
    \item \textbf{Suporte Avançado a Dados}: Compatível com tipos complexos, como JSON, arrays, e dados geoespaciais (\textit{PostGIS}).
    \item \textbf{Alta Conformidade com Padrões SQL}: Facilita a portabilidade de aplicações entre diferentes bancos de dados.
    \item \textbf{Extensibilidade}: Suporte a funções definidas pelo usuário, tipos de dados customizados e linguagens de programação adicionais.
    \item \textbf{Desempenho e Escalabilidade}: Otimizações para consultas complexas e grandes volumes de dados, com suporte a replicação e particionamento.
    \item \textbf{Segurança}: Autenticação robusta, criptografia e controle granular de permissões.
    \item \textbf{Comunidade Ativa}: Grande quantidade de documentação e suporte da comunidade global.
\end{itemize}

\section{Arquitetura do Software}

\subsection{Desenvolvimento Cliente-Servidor}

A construção de uma aplicação percorre várias etapas, desde a concepção da ideia e validação até a prototipação e, seguidamente, codificação resultando em uma solução. Para atingir esse objetivo de maneira eficiente, é necessário escolher ferramentas e tecnologias que suportem  o tamanho e robustez que a aplicação se propõe. No projeto Learn Chain, serão utilizadas tecnologias que atendam esses critérios.

Do lado do servidor, a aplicação será escrita a partir do framework NestJS, que se destaca por seu conjunto de ferramentas integradas capazes de comunicar-se com o banco de dados e construção de APIs rapidamente. É uma ferramenta contruída em JavaScript / TypeScript que proporcionará uma integração boa com o OrbitDB, haja visto que este é escrito na mesma linguagem.

Para o desenvolvimento do lado do cliente será adotado o nextJS, que atualmente é um framework amplamente utilizado por conta de suas facilidades no desenvolvimento web.

\subsection{Arquitetura de desenvolvimento web}

A arquitetura \textit{cliente-servidor} será adotada no desenvolvimento da aplicação, devido à sua robustez e flexibilidade no gerenciamento de interações entre usuários e servidores. Nesse modelo, os clientes fazem requisições a um servidor centralizado, que processa as solicitações e retorna as respostas adequadas. A utilização dessa abordagem oferece uma série de benefícios importantes para o desenvolvimento de sistemas distribuídos. A seguir, estão algumas vantagens deste modelo arquitetural.

\subsection{Principais vantagens do modelo Cliente-Servidor}

\begin{itemize}
    \item \textbf{Controle:} Apesar do cerne dessa aplicação ser a descentralização e democratização dos dados, a gestão dos usuários, bem como o controle do meio de pagamento via rede lightning foi pensado em uma aplicação centralizada. Com esse modelo é possível garantir a integridade e a consistência das informações. 
    Isso permite que a administração tenha maior controle, minimizando riscos de dados corrompidos ou acesso não autorizado\cite{coulouris2011}.
    
    \item \textbf{Escalabilidade:} A arquitetura cliente-servidor comporta um grande número de usuários. As aplicações nessa estrutura podem ser aprimoradas com mais recursos de acordo com a demanda \cite{coulouris2011}.
    
    \item \textbf{Desempenho e Eficiência:} A separação clara entre duas entidades corrobora com a performance da aplicação. O cliente foca na interação com o usuário e como esse dado será apresentado a ele. O servidor lida com processamento e armazenamento de dados. \cite{coulouris2011}.
    
    \item \textbf{Facilidade de Manutenção e Atualização:} Como o processamento centralizado ocorre no servidor, qualquer atualização ou manutenção do sistema pode ser realizada em um único ponto. Isso facilita a implementação de novos recursos, correção de falhas ou melhorias no sistema sem a necessidade de alterar os clientes \cite{coulouris2011}.
    
    \item \textbf{Flexibilidade e Compatibilidade:} Com essa arquitetura é possível distribuir a aplicação para uma gama de plataformas e alcançar um número maior de clintes, como aplicativos móveis, web ou desktop. \cite{coulouris2011}. 
\end{itemize}

\section{Diagrama de Gutenberg}

O desenvolvimento da aplicação web, será baseado no diagrama de Gutenberg, que é o modelo que descreve princípios fundamentais de desing que garantem uma experiência de usuário intuitiva e eficiente. Dentre os diversos princípios utilizados, destam-se para o desenvolvimento desse produto, {hierarquia visual}, a \textit{consistência}, \textit{simplicidade} e \textit{leitura} que, quando combinados corretamente, controem uma interface clara e funcional.

O princípio da \textit{hierarquia visual}, conforme proposto por Lidwell, Holden e Butler (2010), reflete a respeito da importância relativa dos elementos. Eles devem ser estruturados de forma intuitiva a fim de guiar o usuário pelas informações centrais. Isso pode ser alcançado através de tamanhos diferentes de fontes, cores  e contraste, tornando mais fácil a interação do usuário.

O princípio da \textit{consistência} será essencial. De acordo com esse esse princípio, os elementos semelhantes devem ser tratados de maneira consistente em todo o projeto, ou seja, sem diferenças de desing que criem confusão no usuário. Esse princípio aumenta a previsibilidade e acelera o aprendizado da interface.

O princípio da \textit{simplicidade} auxilia em manter uma interface limpa e objetiva partindo da organização dos elementos e funcionalidades e com isso ações como eliminar elementos que sobrecarreguem o usuário com informações excessivas. Isso permitire maior foco na interação e nas principais tarefas, aumentando a eficácia do produto.

Por fim, o princípio da \textit{leitura} destaca os padrões de leitura do ocidente. Esse padrão baseia-se no comportamento dos olhos humanos que tendem a começar a leitura do canto superior esquerdo de uma página, indo em direção ao limite esquerdo, repetindo esse comportamento até o final da leitura \cite{lidwell2010}. Esse padrão é fundamental na concepção de desings, pois dispõe informações a respeito da disposição dos componentes visuais da tela.

\section{Heurísticas de Nielsen}

As heurísticas de Nielsen são importantes princípios para a elaboração de interfaces de usuário. Elas são regras que tem por finalidade descobrir grandes e potenciais problemas da interface analisada \cite{nielsen1994usability}, e sendo assim, são poderosas ferramentas para o desenvolvimento e evolução de sítios web, mesmo que os ambientes e interações tenham evoluído consideravelmente desde sua criação.

As regras estabelecidas por Nielsen estão intimamente ligadas aos métodos de avaliação de interface, onde a maioria desdes são baseados em engenharia cognitiva, cuja finalidade é o desenvolvimento de softwares que exijam do utilizador baixa carga cognitiva para serem utilizados, sendo fáceis de aprender, usar e que sejam agradáveis aos seus usuários \cite{maciel2004avaliacao}.

\subsection{As heurísticas de Nielsen}

De acordo com a obra \cite{nielsen1994usability}, de Nielsen e Molich, são estas as heurísticas de usabilidade:

\begin{itemize}
    \item Visibilidade do estado: o sistema deve manter os usuários informados sobre seu atual estado através de feedback apropriado, dentro de um tempo satisfatório.
    \item Correspondência entre sistema e realidade: o software deve fser baseado em palavras, símbolos e conceitos familiares ao usuário.
    \item Controle do usuário e liberdade: os usuários devem ser capazes de fazer e desfazer procedimentos, proporcionando uma saída fácil de qualquer estado indesejado.
    \item Consistência e padrões: siga convenções de usabilidade e padrões, afim de não confundir os usuários do sistema.
    \item Prevenção de erros: o sistema deve prevenir a ocorrência de erros sempre que possível, por meio de restrições ou avisos.
    \item Reconhecimento em vez de memorização: os usuários devem ser capazes de reconhecer informações, e não memorizá-las.
    \item Flexibilidade e eficiência de uso: o software deve oferecer atalhos  afim de possiblitar que usuários experientes operem em menor tempo.
    \item Estética e design minimalista: interfaces não devem possuir elementos desnecessárias ou raramente necessárias.
    \item Ajude os usuários a reconhecerem, diagnosticarem e recuperarem-se de erros: mensagens de erro devem ser claras, indicando o problema e sugerindo uma solução.
    \item Ajuda e documentação: deve ser fácil para os usuários acessar a ajuda e a documentação (preferencimalmente curta).
\end{itemize}

\section{Processos de Design}

No processo de desenvolvimento de aplicações, é necessário considerar outros aspectos além do conhecimento técnico. Para que o produto entregue cumpra as expectativas e necessidades, é essencial adotar um pensamento sistêmico e uma abordagem estratégica. Nesse cenário, diversos métodos se propuseram a guiar a forma como o design é conduzido, garantindo que a experiência do usuário, a viabilidade técnica e os objetivos do negócio sejam equilibrados de maneira eficiente. Para esse trabalho de conclusão de curso, será utilizado o Desing Thinking.



\subsection{Design Thinking}

O Design Thinking é uma abordagem centrada no ser humano para a resolução de problemas, focada na inovação e na criação de soluções eficazes. Ao contrário dos processos tradicionais de desenvolvimento, que muitas vezes seguem um fluxo linear e estruturado, o Design Thinking propõe um modelo mais dinâmico e iterativo, no qual as soluções emergem a partir de ciclos de experimentação, teste e refinamento \cite{browndesignthinking}.

O processo de Desing Thinking pode ser descrito como um sistema de espaços interconectados, ao invés de uma estrutura rígida. Esse sistema pode ser dividido em 3 fases de acordo com Tim Brown:

\begin{itemize}
    \item Inspiração: O objetivo da fase de inspiração é identificar a necessidade do cliente, ou seja, o problema que deve ser resolvido. Nesse processo são comuns pesquisas, entrevistas e análise do comportamento do usuário a fim de entender suas necessidades e identificar oportunidades. 
    \item Ideação: O objetivo da fase de ideação é a geração de ideias inovadoras, a partir das informações obtidas na fase anterior. Nessa fase será produzido artefatos como protótipos para experimentação.
    \item Controle do usuário e liberdade: os usuários devem ser capazes de fazer e desfazer procedimentos, proporcionando uma saída fácil de qualquer estado indesejado.
    \item Implementação: O objetivo da fase de implementação é a materialização das ideias em soluções reais. Sendo o Design Thinking um processo cíclico, é sempre possível revisitar as etapas anteriores para melhorar e refinar o produto final, garantindo que este esteja em conformidade com os anseios do usuário.
\end{itemize}


 