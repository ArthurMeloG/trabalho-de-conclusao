\chapter[Fundamentação Teórica]{Fundamentação Teórica}
\addcontentsline{toc}{chapter}{Fundamentação Teórica}

\section{O problema das aplicações centralizadas}

A arquitetura tradicional em que a internet se baseou, cliente-servidor, tem sido predominante em várias aplicações, como redes sociais, mensageiros, aplicações de busca. Apesar deste modelo ter se mostrado eficiente no decorrer do tempo, ele apresenta desafios significativos como a centralização dos dados. Segundo Wanner \cite{wanner2024}, problemas como a vulnerabilidade dos dados, a privacidade dos usuários e a censura são aspectos a serem avaliados nessa arquitetura que podem acarretar problemas de segurança e confiança. A forte tendência à centralização pode ser confirmada através do estudo da LogicMonitor \cite{logicmonitor2023} que confirma que com a pandemia COVID-19, a migração de dados das empresas para a nuvem foi acelerada 87\% e planeja seguir com esse processo. Diante dessa problemática, soluções como o \textit{InterPlanetary File System} (IPFS), bitcoin, nostr foram pensadas com o cerne na descentralização e democratização dos dados.

Neste projeto, o foco é desenvolver uma plataforma descentralizada para cursos e materiais educativos, utilizando o IPFS para garantir que os dados permaneçam sob o controle direto de seus criadores. A aplicação será responsável por gerenciar os dados dos usuários e no controle dos meios de pagamento através da rede  \textit{Lightning Network} \cite{lightningnetwork} para os conteúdos privados criptografados. Tanto os materiais públicos quanto os privados serão persistidos na rede IPFS. Dessa forma, mesmo que eventualmente essa aplicação saia de circulação ou seja bloqueada, os dados permanecerão disponíveis globalmente ao público.


\section{O \textit{InterPlanetary File System} (IPFS)}
O IPFS é um protocolo distribuído para armazenamento e compartilhamento de dados, que organiza arquivos em uma estrutura baseada em conteúdo, tornando a web mais eficiente e resistente a falhas \cite{ipfs2025}. Com ele é possível persistir os dados da aplicação entre os nós da rede. Isso o torna público, de fato, e replicável por quaisquer usuários que quiserem. Diferente do HTTP, que carrega arquivos de um servidor, o IPFS utiliza um modelo de endereçamento de conteúdo, em que os dados não desacoplados de sua localização e tratados a partir da hash única gerada pelo conteúdo do mesmo.

Entre suas principais características, destacam-se:

\begin{itemize}
    \item \textbf{Identificadores de Conteúdo (CIDs - Content Identifiers)}: cada conteúdo ou arquivo é associado a um endereço único baseado em um hash criptográfico, garantindo sua integridade e imutabilidade.
    
    \item \textbf{Rede Peer-to-Peer (P2P)}: milhares de nós interconectados facilitam a localização e recuperação dos dados distribuídos na rede.
    
    \item \textbf{Armazenamento em Cache}: os dados são armazenados temporariamente na memória cache dos nós, otimizando a largura de banda e melhorando a eficiência na redistribuição de conteúdos.
\end{itemize}

\subsection{OrbitDB: Banco de Dados Distribuído}

O OrbitDB é um banco de dados \textit{serverless} e ponto a ponto (\textit{peer-to-peer}), distribuído construído para atuar em aplicações descentralizadas. Ele usa o IPFS para o armazenamento dos dados e garante a sincronia dos dados entre os diferentes nós. Ele será utilizado no projeto para realizar a comunicação e persistência dos dados com a rede IPFS.

\subsection{Arquitetura de desenvolvimento web}


A arquitetura \textit{cliente-servidor} será adotada no desenvolvimento da aplicação, devido à sua robustez e flexibilidade no gerenciamento de interações entre usuários e servidores. Nesse modelo, os clientes fazem requisições a um servidor centralizado, que processa as solicitações e retorna as respostas adequadas. A utilização dessa abordagem oferece uma série de benefícios importantes para o desenvolvimento de sistemas distribuídos.


A arquitetura escolhida para o desenvolvimento da aplicação é a \textit{cliente-servidor}. Ela será adotada por conta de sua flexibilidade e robustez no gerenciamento de interações entre os usuários e os servidores. Essa parte da aplicação ficará encarregada pelo gerenciamento dos usuários, bem como pelo serviço de gerar as páginas estáticas que serão persistidas na rede ipfs com os dados gerados. O uso de uma abordagem híbrida concilia as vantagens da rede distribuída descritas acima com as vantagens dessa arquitetura:

\subsection{Principais vantagens do modelo Cliente-Servidor}

\begin{itemize}
    \item \textbf{Controle:} Apesar do cerne dessa aplicação ser a descentralização e democratização dos dados, a gestão dos usuários, bem como o controle do meio de pagamento via rede lightning foi pensado em uma aplicação centralizada. Com esse modelo é possível garantir a integridade e a consistência das informações. 
    Isso permite que a administração tenha maior controle, minimizando riscos de dados corrompidos ou acesso não autorizado\cite{coulouris2011}.
    
    \item \textbf{Escalabilidade:} A arquitetura cliente-servidor comporta um grande número de usuários. As aplicações nessa estrutura podem ser aprimoradas com mais recursos de acordo com a demanda \cite{coulouris2011}.
    
    \item \textbf{Desempenho e Eficiência:} A separação clara entre duas entidades corrobora com a performance da aplicação. O cliente foca na interação com o usuário e como esse dado será apresentado a ele. O servidor lida com processamento e armazenamento de dados. \cite{coulouris2011}.
    
    \item \textbf{Facilidade de Manutenção e Atualização:} Como o processamento centralizado ocorre no servidor, qualquer atualização ou manutenção do sistema pode ser realizada em um único ponto. Isso facilita a implementação de novos recursos, correção de falhas ou melhorias no sistema sem a necessidade de alterar os clientes \cite{coulouris2011}.
    
    \item \textbf{Flexibilidade e Compatibilidade:} Com essa arquitetura é possível distribuir a aplicação para uma gama de plataformas e alcançar um número maior de clintes, como aplicativos móveis, web ou desktop. \cite{coulouris2011}.
    
\end{itemize}

Dessa forma, a utilização desse modelo em conjunto com a abordagem descentralizada, contribuíra para o desenvolvimento de uma plataforma escalável, segura, eficiente e democrática.

\section{Desenvolvimento Cliente-Servidor}

A construção de uma aplicação percorre várias etapas, desde a concepção da ideia e validação até a prototipação e, seguidamente, codificação resultando em uma solução. Para atingir esse objetivo de maneira eficiente, é necessário escolher ferramentas e tecnologias que suportem  o tamanho e robustez que a aplicação se propõe. No projeto XXX, serão utilizadas tecnologias que atendam esses critérios.

Do lado do servidor, a aplicação será escrita a partir do framework NestJS, que se destaca por seu conjunto de ferramentas integradas capazes de comunicar-se com o banco de dados e construção de APIs rapidamente. É uma ferramenta contruída em JavaScript / TypeScript que proporcionará uma integração boa com o OrbitDB, haja visto que este é escrito na mesma linguagem.

Para o desenvolvimento do lado do cliente será adotado o nextJS, que atualmente é um framework amplamente utilizado por conta de suas facilidades no desenvolvimento web.

\subsection{NestJS}

NestJS é uma estrutura para construir aplicativos Node.js eficientes e escaláveis. Ele utiliza JavaScript progressivo, sendo construído com e oferecendo suporte total a TypeScript (mas ainda permitindo que os desenvolvedores codifiquem em JavaScript puro) e combina elementos de POO (Programação Orientada a Objetos), FP (Programação Funcional) e FRP (Programação Reativa Funcional) \cite{nestjs2025}. (Texto traduzido por autor).

\subsubsection*{Pontos Fortes do NestJS:}
\begin{itemize}
    \item \textbf{Modularidade}: Arquitetura que facilita a divisão da aplicação em módulos reutilizáveis.
    \item \textbf{Integração simples com bancos de dados}: Compatível com ORM populares, como TypeORM e Prisma.
    \item \textbf{Injeção de Dependência}: Simplifica o gerenciamento de dependências e aumenta a testabilidade.
    \item \textbf{Flexibilidade}: Suporta diversos paradigmas, como programação reativa e microsserviços.
\end{itemize}

\subsection{OrbitDB}

O \textbf{OrbitDB} é um banco de dados distribuído e descentralizado, construído sobre o protocolo \textit{IPFS} (\textit{InterPlanetary File System}). Sua arquitetura descentralizada permite alta disponibilidade e sincronização eficiente de dados entre nós. Como é escrito em \textit{JavaScript}, oferece uma integração perfeita com o NestJS.

\subsubsection*{Pontos Fortes do OrbitDB:}
\begin{itemize}
    \item \textbf{Descentralização}: Dispensa a necessidade de servidores centralizados.
    \item \textbf{Alta disponibilidade}: Suporta replicação automática e sincronização entre nós.
    \item \textbf{Desempenho escalável}: Ideal para aplicações distribuídas que requerem persistência de dados em tempo real.
    \item \textbf{Fácil integração}: Compatível com tecnologias baseadas em JavaScript.
\end{itemize}

\subsection{Next.js}

O \textbf{Next.js} é um framework \textit{React} para desenvolvimento de aplicações no lado do cliente. Ele oferece recursos como renderização no lado do servidor (\textit{Server-Side Rendering} - SSR) e geração de sites estáticos (\textit{Static Site Generation} - SSG), que permitem criar interfaces modernas com excelente desempenho.

\subsubsection*{Pontos Fortes do Next.js:}
\begin{itemize}
    \item \textbf{Renderização otimizada}: Suporte a SSR e SSG, melhorando o desempenho e SEO.
    \item \textbf{Rotas automáticas}: Simplifica a estrutura de navegação com rotas baseadas em arquivos.
    \item \textbf{Desenvolvimento eficiente}: Hot reloading e compilação automática durante o desenvolvimento.
    \item \textbf{API Routes}: Permite criar APIs no mesmo projeto do front-end.
    \item \textbf{Suporte ativo da comunidade}: Grande número de extensões e soluções prontas.
\end{itemize}

\subsection{PostgreSQL}

O \textbf{PostgreSQL} é um banco de dados relacional muito utilizado no desenvolvimento web. Conhecido por sua flexibilidade e robustez em diagramas relacionais. 

\subsubsection*{Pontos Fortes do PostgreSQL:}
\begin{itemize}
    \item \textbf{Suporte Avançado a Dados}: Compatível com tipos complexos, como JSON, arrays, e dados geoespaciais (\textit{PostGIS}).
    \item \textbf{Alta Conformidade com Padrões SQL}: Facilita a portabilidade de aplicações entre diferentes bancos de dados.
    \item \textbf{Extensibilidade}: Suporte a funções definidas pelo usuário, tipos de dados customizados e linguagens de programação adicionais.
    \item \textbf{Desempenho e Escalabilidade}: Otimizações para consultas complexas e grandes volumes de dados, com suporte a replicação e particionamento.
    \item \textbf{Segurança}: Autenticação robusta, criptografia e controle granular de permissões.
    \item \textbf{Comunidade Ativa}: Grande quantidade de documentação e suporte da comunidade global.
\end{itemize}

\section{Diagrama de Gutenberg}

O desenvolvimento da aplicação web, será baseado no diagrama de Gutenberg, que é o modelo que descreve princípios fundamentais de desing que garantem uma experiência de usuário intuitiva e eficiente. Dentre os diversos princípios utilizados, destam-se para o desenvolvimento desse produto, {hierarquia visual}, a \textit{consistência}, \textit{simplicidade} e \textit{leitura} que, quando combinados corretamente, controem uma interface clara e funcional.

O princípio da \textit{hierarquia visual}, conforme proposto por Lidwell, Holden e Butler (2010), reflete a respeito da importância relativa dos elementos. Eles devem ser estruturados de forma intuitiva a fim de guiar o usuário pelas informações centrais. Isso pode ser alcançado através de tamanhos diferentes de fontes, cores  e contraste, tornando mais fácil a interação do usuário.

O princípio da \textit{consistência} será essencial. De acordo com esse esse princípio, os elementos semelhantes devem ser tratados de maneira consistente em todo o projeto, ou seja, sem diferenças de desing que criem confusão no usuário. Esse princípio aumenta a previsibilidade e acelera o aprendizado da interface.

O princípio da \textit{simplicidade} auxilia em manter uma interface limpa e objetiva partindo da organização dos elementos e funcionalidades e com isso ações como eliminar elementos que sobrecarreguem o usuário com informações excessivas. Isso permitire maior foco na interação e nas principais tarefas, aumentando a eficácia do produto.

Por fim, o princípio da \textit{leitura} destaca os padrões de leitura do ocidente. Esse padrão baseia-se no comportamento dos olhos humanos que tendem a começar a leitura do canto superior esquerdo de uma página, indo em direção ao limite esquerdo, repetindo esse comportamento até o final da leitura \cite{lidwell2010}. Esse padrão é fundamental na concepção de desings, pois dispõe informações a respeito da disposição dos componentes visuais da tela.

\section{Heurísticas de Nielsen}

As heurísticas de Nielsen são importantes princípios para a elaboração de interfaces de usuário. Elas são regras que tem por finalidade descobrir grandes e potenciais problemas da interface analisada \cite{nielsen1994usability}, e sendo assim, são poderosas ferramentas para o desenvolvimento e evolução de sítios web, mesmo que os ambientes e interações tenham evoluído consideravelmente desde sua criação.

As regras estabelecidas por Nielsen estão intimamente ligadas aos métodos de avaliação de interface, onde a maioria desdes são baseados em engenharia cognitiva, cuja finalidade é o desenvolvimento de softwares que exijam do utilizador baixa carga cognitiva para serem utilizados, sendo fáceis de aprender, usar e que sejam agradáveis aos seus usuários \cite{maciel2004avaliacao}.

\subsection{As heurísticas de Nielsen}

De acordo com a obra \cite{nielsen1994usability}, de Nielsen e Molich, são estas as heurísticas de usabilidade:

\begin{itemize}
    \item Visibilidade do estado: o sistema deve manter os usuários informados sobre seu atual estado através de feedback apropriado, dentro de um tempo satisfatório.
    \item Correspondência entre sistema e realidade: o software deve fser baseado em palavras, símbolos e conceitos familiares ao usuário.
    \item Controle do usuário e liberdade: os usuários devem ser capazes de fazer e desfazer procedimentos, proporcionando uma saída fácil de qualquer estado indesejado.
    \item Consistência e padrões: siga convenções de usabilidade e padrões, afim de não confundir os usuários do sistema.
    \item Prevenção de erros: o sistema deve prevenir a ocorrência de erros sempre que possível, por meio de restrições ou avisos.
    \item Reconhecimento em vez de memorização: os usuários devem ser capazes de reconhecer informações, e não memorizá-las.
    \item Flexibilidade e eficiência de uso: o software deve oferecer atalhos  afim de possiblitar que usuários experientes operem em menor tempo.
    \item Estética e design minimalista: interfaces não devem possuir elementos desnecessárias ou raramente necessárias.
    \item Ajude os usuários a reconhecerem, diagnosticarem e recuperarem-se de erros: mensagens de erro devem ser claras, indicando o problema e sugerindo uma solução.
    \item Ajuda e documentação: deve ser fácil para os usuários acessar a ajuda e a documentação (preferencimalmente curta).
\end{itemize}